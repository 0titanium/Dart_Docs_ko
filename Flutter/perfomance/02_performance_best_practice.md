# 성능 모범 사례  Performance best practices

```
노트

성능 문제를 디버깅하기 위해 Flutter DevTools의 Performance View를 사용하는 방법을 배우려면 "Using the Performance view"를 참조하세요. 
```

일반적으로 Flutter 애플리케이션은 기본적으로 성능이 우수하므로, 흔한 실수를 피하기만 하면 좋은 성능을 유지할 수 있습니다. 이러한 모범 사례 권장 사항은 가장 성능이 뛰어난 Flutter 앱을 작성하는 데 도움이 될 것입니다.

```
노트

만약 Flutter로 웹 애플리케이션을 작성하고 있다면, Flutter Material 팀이 Flutter Gallery 앱을 웹에서 더 성능 좋게 만들기 위해 수정한 후 작성한 일련의 글들이 도움이 될 수 있습니다:

- 트리 셰이킹과 지연 로딩을 통한 Flutter 웹 앱 성능 최적화
- 이미지 플레이스홀더, 프리캐싱 및 네비게이션 전환 비활성화를 통한 체감 성능 향상
- 성능이 우수한 Flutter 위젯 구축
```

Flutter 앱에서 장면을 가장 효율적으로 렌더링하려면 어떻게 설계해야 할까요? 특히, 프레임워크에서 생성된 그리기 코드가 가능한 한 효율적이도록 어떻게 보장하나요? 일부 렌더링 및 레이아웃 작업은 느린 것으로 알려져 있지만 항상 피할 수는 없습니다. 이러한 작업은 아래의 지침을 따라 신중하게 사용해야 합니다.

## 비용이 많이 드는 작업 최소화 Minimize expensive operations

일부 작업은 다른 작업보다 비용이 더 많이 드는데, 이는 더 많은 리소스를 소비한다는 의미입니다. 당연히 이러한 작업은 필요할 때만 사용해야 합니다. 앱의 UI를 설계하고 구현하는 방식이 앱의 실행 효율성에 큰 영향을 미칠 수 있습니다.

### build() 비용 제어 Control build() cost

UI를 설계할 때 다음 사항을 염두에 두세요.

- build() 메서드에서 반복적이고 비용이 많이 드는 작업을 피하세요. build()는 상위 위젯이 다시 빌드될 때 자주 호출될 수 있습니다.
- 큰 build() 함수를 가진 대형 단일 위젯을 피하고, 변경 사항과 캡슐화 기준에 따라 여러 위젯으로 분리하세요.
- setState() 호출을 로컬화하세요. State 객체에서 setState()를 호출하면 모든 하위 위젯이 다시 빌드되므로, 실제로 UI가 변경되는 하위 트리 부분에만 사용하고, 트리 상단에서는 호출을 피하세요.
- 동일한 자식 위젯 인스턴스를 다시 만나면 하위 위젯을 재구성하는 작업이 중단됩니다. 이 기술은 애니메이션에서 자식 트리에 영향을 주지 않도록 최적화하는 데 자주 사용됩니다. TransitionBuilder 패턴과 SlideTransition의 소스 코드를 참고하세요.
- 위젯에 가능한 한 const 생성자를 사용하세요. 이를 통해 Flutter는 대부분의 재빌드 작업을 건너뛸 수 있습니다. const 사용을 자동으로 상기하려면 flutter_lints 패키지의 권장 린트를 활성화하세요.
- 재사용 가능한 UI 구성 요소를 만들 때는 함수보다 StatelessWidget을 사용하는 것이 좋습니다.

추가 정보는 다음을 참고하세요:

- StatefulWidget API 문서의 성능 고려 사항
- 공식 Flutter YouTube 채널의 "Widgets vs helper methods" 영상

### saveLayer()를 신중하게 사용하세요  Use saveLayer() thoughtfully

일부 Flutter 코드에서는 다양한 시각적 효과를 구현하기 위해 saveLayer()라는 비용이 많이 드는 작업을 사용합니다. 코드에서 saveLayer()를 명시적으로 호출하지 않더라도, 사용하는 다른 위젯이나 패키지가 백그라운드에서 이를 호출할 수 있습니다. 만약 앱이 불필요하게 saveLayer()를 많이 호출하고 있다면, 과도한 호출이 지연을 유발할 수 있습니다.

#### saveLayer가 비용이 많이 드는 이유 Why is saveLayer expensive?

saveLayer()를 호출하면 오프스크린 버퍼가 할당되고, 오프스크린 버퍼에 내용을 그리면 렌더 타겟 전환이 발생할 수 있습니다. GPU는 빠르게 처리하려고 하지만, 렌더 타겟 전환은 GPU가 스트림을 일시적으로 다른 곳으로 전환했다가 다시 원래대로 되돌리게 만듭니다. 모바일 GPU에서는 이 작업이 렌더링 처리량에 큰 영향을 미칠 수 있습니다.

#### saveLayer는 언제 필요한가요? When is saveLayer required?

런타임에서 서버에서 오는 다양한 형태(예: 투명도가 있는 도형)를 동적으로 표시해야 하고, 이 도형들이 겹칠 수도 있는 경우에는 saveLayer()를 사용해야 할 수 있습니다.

#### saveLayer 호출 디버깅 Debugging calls to saveLayer

앱이 saveLayer()를 직접 또는 간접적으로 얼마나 자주 호출하는지 확인하려면, saveLayer() 메서드는 DevTools 타임라인에서 이벤트를 트리거합니다. DevTools의 성능 보기에서 PerformanceOverlayLayer.checkerboardOffscreenLayers 스위치를 확인하여 씬에서 saveLayer가 언제 사용되는지 알 수 있습니다.

#### saveLayer 호출 최소화 Minimizing calls to saveLayer

saveLayer 호출을 피할 수 있을까요? 시각적 효과를 만드는 방식을 재고해야 할 수도 있습니다:

- 호출이 코드에서 발생하는 경우, 이를 줄이거나 제거할 수 있을까요? 예를 들어, UI가 두 개의 도형을 겹치게 하여 각 도형에 투명도가 있을 경우:

  - 만약 두 도형이 항상 같은 방식, 같은 양, 같은 투명도로 겹친다면, 겹쳐진 반투명 객체가 어떻게 보일지를 미리 계산하고 캐시한 후, saveLayer()를 호출하는 대신 이를 사용할 수 있습니다. 이는 미리 계산할 수 있는 정적 도형에 적용 가능합니다.
  
- 페인팅 로직을 리팩터링하여 겹침을 아예 없앨 수 있을까요?

- 호출이 사용 중인 패키지에서 발생하는 경우, 패키지 소유자에게 연락하여 왜 이러한 호출이 필요한지 물어보고, 이를 줄이거나 제거할 수 있는지 확인하세요. 만약 그렇지 않다면 다른 패키지를 찾아야 하거나, 직접 구현해야 할 수도 있습니다.

```
패키지 소유자 노트

최선의 실천 방법으로, saveLayer가 패키지에서 필요할 수 있는 상황, 이를 피할 수 있는 방법, 그리고 피할 수 없는 경우에 대한 문서를 제공하는 것을 고려하세요.
```

saveLayer()를 트리거할 수 있는 다른 위젯들로는 다음과 같습니다:

- ShaderMask
- ColorFilter
- Chip : disabledColorAlpha가 0xff가 아니면 saveLayer() 호출을 유발할 수 있음
- Text : overflowShader가 있을 경우 saveLayer() 호출을 유발할 수 있음

### 불투명도(opacity)와 클리핑(clipping) 사용을 최소화하세요 Minimize use of opacity and clipping

불투명도(opacity)와 클리핑(clipping)은 비용이 많이 드는 작업입니다. 다음은 유용할 수 있는 몇 가지 팁입니다:

- 불투명도 위젯은 필요할 때만 사용하세요. Opacity API 페이지의 투명 이미지 섹션을 참조하면, 이미지를 직접 불투명도를 적용하는 것이 Opacity 위젯을 사용하는 것보다 빠르다는 예시를 확인할 수 있습니다.
- 간단한 도형이나 텍스트를 Opacity 위젯으로 감싸는 대신, 반투명 색상으로 그리는 것이 일반적으로 더 빠릅니다. (단, 그려지는 도형에 겹치는 부분이 없을 때만 적용됩니다.)
- 이미지에 페이딩 효과를 구현하려면 FadeInImage 위젯을 사용하는 것을 고려하세요. 이 위젯은 GPU의 프래그먼트 셰이더를 사용하여 점진적인 불투명도를 적용합니다. 더 자세한 내용은 Opacity 문서를 확인하세요.
- 클리핑은 saveLayer()를 호출하지 않지만(Clip.antiAliasWithSaveLayer로 명시적으로 요청한 경우 제외), 여전히 비용이 많이 들 수 있으므로 주의해서 사용해야 합니다. 기본적으로 클리핑은 비활성화되어 있으므로 필요할 때 명시적으로 활성화해야 합니다.
- 둥근 모서리를 가진 사각형을 만들 때, 클리핑 사각형을 적용하는 대신, 많은 위젯 클래스에서 제공하는 borderRadius 속성을 사용하는 것이 좋습니다.

### 그리드와 리스트를 신중하게 구현하세요 Implement grids and lists thoughtfully

그리드와 리스트를 구현하는 방식이 앱의 성능 문제를 일으킬 수 있습니다. 이 섹션에서는 그리드와 리스트를 생성할 때 중요한 최선의 실천 방법과, 앱이 과도한 레이아웃 패스를 사용하는지 확인하는 방법에 대해 설명합니다.

#### 지연하세요!

큰 그리드나 리스트를 만들 때는 콜백을 사용하는 지연 빌더 방법을 사용하세요. 이렇게 하면 화면에서 보이는 부분만 시작 시에 빌드됩니다.

더 많은 정보와 예시는 다음을 참조하세요:

- 쿡북에서 긴 리스트 작업하기
- AbdulRahman AlHamali의 커뮤니티 기사: 한 번에 하나의 페이지를 로드하는 ListView 만들기
- Listview.builder API

#### 내장 함수 피하기 Avoid intrinsics

그리드와 리스트에서 내재적인 패스가 문제를 일으킬 수 있는 방법에 대한 정보는 다음 섹션을 참조하세요.

### 내재적 작업으로 인한 레이아웃 패스를 최소화하세요 Minimize layout passes caused by intrinsic operations

Flutter 프로그래밍을 많이 해보았다면 UI를 만들 때 레이아웃과 제약 조건이 어떻게 작동하는지 잘 알고 있을 것입니다. 아마 Flutter의 기본 레이아웃 규칙도 외웠을 것입니다: 제약 조건은 내려가고, 크기는 올라가며, 부모가 위치를 설정합니다.

그리드와 리스트와 같은 일부 위젯의 경우, 레이아웃 프로세스가 비용이 많이 들 수 있습니다. Flutter는 위젯에 대해 한 번의 레이아웃 패스만 수행하려고 하지만, 때때로 두 번째 패스(내재적 패스)가 필요하고, 이로 인해 성능이 저하될 수 있습니다.

#### 내재적 패스가 무엇입니까? What is an intrinsic pass?

내재적 패스는 예를 들어, 모든 셀이 가장 큰 셀 또는 가장 작은 셀의 크기와 같도록 하거나, 모든 셀을 조회해야 하는 유사한 계산을 수행할 때 발생합니다.

예를 들어, 카드의 큰 그리드를 생각해 보세요. 그리드는 균일한 크기의 셀을 가져야 하므로, 레이아웃 코드는 그리드의 루트(위젯 트리)에서 시작하여 그리드의 모든 카드(보이는 카드만이 아닌)에게 내재적 크기—제약이 없는 경우 위젯이 선호하는 크기를 반환하도록 요청하는 패스를 수행합니다. 이 정보를 바탕으로 프레임워크는 균일한 셀 크기를 결정하고, 두 번째로 모든 그리드 셀을 다시 방문하여 각 카드에 사용할 크기를 알려줍니다.

#### 내재적 패스 디버깅 Debugging intrinsic passes

과도한 내재적 패스가 발생하는지 확인하려면 DevTools에서 "Track layouts" 옵션을 활성화하세요(기본적으로 비활성화됨). 그런 다음 앱의 스택 트레이스를 확인하여 몇 번의 레이아웃 패스가 수행되었는지 확인할 수 있습니다. 추적을 활성화하면 내재적 타임라인 이벤트가 '$runtimeType intrinsics'로 표시됩니다.

#### 내재적 패스 피하기 Avoiding intrinsic passes

내재적 패스를 피할 수 있는 몇 가지 방법이 있습니다:

1. 셀의 크기를 처음부터 고정 크기로 설정합니다.
2. 특정 셀을 "앵커" 셀로 선택하여, 모든 셀이 이 셀을 기준으로 크기를 설정하도록 합니다. 그런 다음 사용자 정의 RenderObject를 작성하여 자식 앵커를 먼저 배치하고, 그 주변에 다른 자식들을 배치합니다.

레이아웃이 어떻게 작동하는지 더 깊이 이해하려면, Flutter 아키텍처 개요의 레이아웃 및 렌더링 섹션을 확인해 보세요.

### 16ms 내에 프레임을 빌드하고 표시하세요. Build and display frames in 16ms

60Hz 디스플레이에서는 빌딩과 렌더링을 위한 두 개의 별도 스레드가 있으므로, 빌딩에는 16ms, 렌더링에는 16ms가 주어집니다. 지연 시간이 중요하다면, 16ms 이내에 프레임을 빌드하고 표시해야 합니다. 이는 빌딩이 8ms 이하, 렌더링이 8ms 이하로 완료되어야 한다는 의미입니다.

프로파일 모드에서 프레임 렌더링 시간이 16ms 미만이라면, 성능에 큰 문제가 없을 가능성이 높습니다. 하지만 여전히 가능한 한 빠르게 프레임을 빌드하고 렌더링하는 것을 목표로 해야 합니다. 그 이유는 다음과 같습니다:

- 프레임 렌더링 시간을 16ms 이하로 낮추는 것이 시각적인 차이를 만들지 않더라도, 배터리 수명과 열 문제를 개선할 수 있습니다.
- 기기에서는 잘 실행될 수 있지만, 목표로 하는 최저 사양 기기에서의 성능을 고려해야 합니다.
- 120fps 기기가 점점 더 보편화됨에 따라, 가장 부드러운 경험을 제공하기 위해서는 8ms 이하(총 8ms 이하)로 프레임을 렌더링해야 합니다.
- 60fps가 왜 부드러운 시각적 경험을 제공하는지 궁금하다면, "Why 60fps?" 비디오를 확인해 보세요.

## 함정 Pitfalls

앱의 성능을 조정해야 하거나 UI가 예상만큼 부드럽지 않다면, DevTools의 성능 뷰가 도움이 될 수 있습니다!

또한, IDE의 Flutter 플러그인도 유용할 수 있습니다. Flutter 성능 창에서 "Show widget rebuild information" 체크박스를 활성화하세요. 이 기능은 16ms 이상으로 프레임이 렌더링되고 표시될 때를 감지하는 데 도움이 됩니다. 가능하면 플러그인이 관련 팁에 대한 링크를 제공합니다.

다음 동작들은 앱의 성능에 부정적인 영향을 미칠 수 있습니다:

- Opacity 위젯 사용 피하기: 특히 애니메이션에서 사용을 피하세요. 대신 AnimatedOpacity나 FadeInImage를 사용하세요. 애니메이션에서 불투명도 성능 고려사항을 확인하세요.
  
- AnimatedBuilder 사용 시: 애니메이션과 관계없는 위젯을 builder 함수 내 서브트리로 두지 마세요. 이 서브트리는 애니메이션의 모든 틱마다 다시 빌드됩니다. 대신, 그 부분을 한 번만 빌드하고, AnimatedBuilder에 자식으로 전달하세요. 성능 최적화에 대해 자세히 알아보세요.
  
- 애니메이션에서 클리핑 피하기: 가능하면 애니메이션 전에 이미지를 미리 클리핑하세요.
  
- 화면에 보이지 않는 대부분의 자식이 있는 생성자 사용 피하기: 예를 들어 Column()이나 ListView()에서 보이지 않는 자식들이 많다면 빌드 비용을 피하기 위해 사용을 피하세요.
  
- 위젯 객체에서 operator == 오버라이드 피하기: 불필요한 재빌드를 피하려는 것처럼 보일 수 있지만, 실제로는 O(N²) 동작을 초래할 수 있어 성능에 해로울 수 있습니다. 이 규칙의 유일한 예외는 자식이 없는 리프 위젯(구성 변경이 드물고, 위젯을 재빌드하는 것보다 속도가 더 빠를 경우)입니다. 그런 경우에도 일반적으로 위젯을 캐시하는 것이 더 바람직합니다.

## 자원 Resources

성능에 관한 더 많은 정보를 원하시면, 아래 리소스를 확인해 보세요:

- AnimatedBuilder API 페이지의 성능 최적화
- Opacity API 페이지의 불투명도 애니메이션 성능 고려사항
- ListView API 페이지의 자식 요소 생애 주기와 효율적인 로딩 방법
- StatefulWidget의 성능 고려사항
- Flutter 웹 로딩 속도 최적화를 위한 모범 사례